include: all_lint_rules.yaml
analyzer:
  exclude:
    - "**/*.g.dart"

  # For more information see: https://dart.dev/tools/analysis
  language:
    strict-casts: true
    strict-inference: true
    strict-raw-types: true

  errors:
    # Without ignore here, we cause import of all_lint_rules to warn, because some rules conflict.
    # We explicitly enable conflicting rules and are fixing the conflicts in this file.
    # Put it to warning temporarily if you need to troubleshoot lint rule settings.
    included_file_warning: ignore

    # Treat missing required parameters as an error, not as a hint or a warning.
    missing_required_param: error

    # Treat missing returns as an error, not as a hint or a warning.
    missing_return: error

    # A record literal with exactly one positional field requires a trailing comma.
    record_literal_one_positional_no_trailing_comma: error

    # Invocation collection methods with arguments of unrelated types.
    collection_methods_unrelated_type: warning

    # Invocation of equality operator == with references of unrelated types.
    unrelated_type_equality_checks: warning

    # DON'T assign new values to parameters of methods or functions.
    #
    # https://dart.dev/tools/linter-rules/parameter_assignments.html
    #
    # Treats assigning new values to a parameter as a warning. We would almost like to set this
    # to an error. However, this warning rule, or even more so if you set it to be an error, may
    # be a bit problematic if/when you include other code directly that does it a lot.
    # It does, however, make code safer when this cannot be done without involving
    # an extra local variable for clarity and safety. Enabling this error, even as just a warning,
    # does get in the way a bit if all you want to do is a null to default value release runtime
    # safety/fallback assignment. For that use case, you have to add a local rule override. With
    # null-safety, the need for this kind of null check and re-assignment to default if null,
    # is rarely needed. Considering the comment in:
    # https://dart.dev/tools/linter-rules/parameter_assignments.html:
    # "Assigning new values to parameters is generally a bad practice unless an operator
    # such as ??= is used. Otherwise, arbitrarily reassigning parameters is usually a mistake."
    # One might even think the rule would allow using the ??= operator, but it does not. For now,
    # we keep this lint as warning and overriding locally with:
    #
    # When we need it for the ??= operator, or some copy/pasted in code that does things that
    # require it, that we don't want to deal with fixing at the moment.
    parameter_assignments: warning

    # Allow having TODOs in the code.
    todo: ignore

# LINTER Preferences
#
# Explicitly disable only the rules we do not want.
linter:
  rules:

    # ALWAYS separate the control structure expression from its statement.
    #
    # https://dart.dev/tools/linter-rules/always_put_control_body_on_new_line.html
    #
    # This sometimes makes things more unclear when one line is enough. Also, single line if:s are
    # fine and also recommended in Effective Dart "DO format your code using dartfmt".
    always_put_control_body_on_new_line: false

    # ALWAYS specify @required on named parameter before other named parameters.
    #
    # https://dart.dev/tools/linter-rules/always_put_required_named_parameters_first.html
    #
    # Conflicts with the convention used by Flutter, which puts `Key key` first
    # and `@required Widget child` last.
    always_put_required_named_parameters_first: false

    # ALWAYS use package imports for files in lib/.
    #
    # https://dart.dev/tools/linter-rules/always_use_package_imports.html
    #
    # This rule conflicts with `prefer_relative_imports` so we turn it OFF.
    # We are still conflicted about which version to use, keeping it this way for now. Support
    # for relative imports has improved in both IDEs. Adding imports still often get imported as
    # package imports, and then you have to edit them manually. The IDEs can help with fixing them.
    # The relative paths can be a bit messy to keep track off, package imports are actually
    # a bit easier from that point of view.
    # Flutter repo now also prefers relative imports over package imports, so that is
    # another reason to use that.
    #
    # Use what you prefer, but you have to be consistent though, since mixing and matching can
    # cause issues as the same file imported with the different options are considered to be
    # different libs and code, even if it is the same file. This may impact the functionality
    # of e.g. singletons, service locators and increase code size.
    #
    # When you refactor and move folders with a lot of code in them, that other code depends
    # on for imports via relative imports, then they get messed up by Flutter IDEs
    # VS-Code and AS/IntelliJ. Both main Flutter IDEs may fail to correctly refactor moved folders
    # and imports that depend on files in the moved folders.
    always_use_package_imports: false

    # AVOID annotating with dynamic when not required.
    #
    # https://dart.dev/tools/linter-rules/avoid_annotating_with_dynamic.html
    #
    # Violates Effective Dart "PREFER annotating with dynamic instead of letting inference fail", it
    # also conflicts with strong mode disabling `implicit-dynamic`. Turning it OFF.
    avoid_annotating_with_dynamic: false

    # AVOID catches without on clauses.
    #
    # https://dart.dev/tools/linter-rules/avoid_catches_without_on_clauses.html
    #
    # Using catch clauses without on clauses makes your code prone to encountering unexpected
    # errors that won't be thrown (and thus will go unnoticed). However, there are situations
    # where we voluntarily want to catch everything, especially as a library.
    # See https://github.com/dart-lang/linter/issues/3023
    #
    # The above issue has been resolved and closed, so the rule is now enabled
    # starting in version 2.3.0.
    avoid_catches_without_on_clauses: false

    # AVOID defining a class that contains only static members.
    #
    # https://dart.dev/tools/linter-rules/avoid_classes_with_only_static_members.html
    #
    # Creating classes with the sole purpose of providing utility, or otherwise static methods, is
    # discouraged in effective Dart. Dart allows functions to exist outside of classes for this
    # very reason. Effective Dart says avoid classes with only static members:
    # https://dart.dev/guides/language/effective-dart/design#avoid-defining-a-class-that-contains-only-static-members
    # However, the Flutter style guide says use them when it makes sense:
    # https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#begin-global-constant-names-with-prefix-k
    # Colors is an example of such a class, but they still enable this rule in the repo though, go figure.
    #
    # Like Pedantic, we like util and static classes too, so we use them.
    # We tried the Effective Dart style and used kConstants in different const files. This
    # is more cumbersome to use than static classes. The import is simpler with static classes and
    # the code looks cleaner. If you use a lot of constant files, importing them is more tedious,
    # and you cannot enforce a given 'as' name to have a consistent name space prefix. A static
    # class gives you that automatically, thus providing context for the constants and static functions.
    avoid_classes_with_only_static_members: false

    # AVOID positional boolean parameters.
    #
    # https://dart.dev/tools/linter-rules/avoid_positional_boolean_parameters.html
    #
    # Positional boolean parameters are considered a bad practice because they are very ambiguous.
    # Using named boolean parameters is much more readable because it inherently describes
    # what the boolean value represents.
    # In principle, we agree with the argument against positional booleans. However, positional booleans
    # are OK when they are the ONLY boolean parameter in a callback, and also very handy when used in a
    # model setter from the callback directly.
    #
    # Flutter API contains many callbacks with the signature: {void Function(bool) onChanged} often
    # for UI toggle switches. To keep things tidy and clean with a model setter for such a callback,
    # a setter method with a positional boolean is needed, a typical pattern is:
    # Switch.adaptive(
    #   value: model.hideTooltips,
    #   onChanged: model.setHideTooltips,
    # ),
    #
    # We are turning OFF this AVOID rule. Willing to reconsider if I get convinced there are better ways,
    # and it does not get in the way of single none named bool callbacks.
    avoid_positional_boolean_parameters: false

    # AVOID redundant argument values.
    #
    # https://dart.dev/tools/linter-rules/avoid_redundant_argument_values.html
    #
    # Using redundant (default) argument values can be useful for in-code documentation
    # purposes and also handy as a template when trying different settings in Flutter. It is often
    # quicker when dealing with not well-known APIs to see parameter values in the call/constructor,
    # instead of using the IDE to peek into its default to figure out what the defaults are.
    # Occasionally, leaving a few redundant default valued parameters in the code is not that bad
    # when you are developing something new. For public packages, you probably want to keep this
    # rule enabled. I like to sometimes be explicit and specify values that are the same as
    # default one, mostly to make an unfamiliar API more readable on GitHub.
    avoid_redundant_argument_values: false

    # AVOID annotating types for function expression parameters.
    #
    # https://dart.dev/tools/linter-rules/avoid_catches_without_on_clauses.html
    #
    # Annotating types for function expression parameters is usually unnecessary because the
    # parameter types can almost always be inferred from the context, thus making the practice redundant.
    # However, since we are using `always_specify_types`, we should not have this one ON either
    # as it conflicts with it. Even if you do not do that, we still recommend keeping this rule OFF.
    # While always specifying the type on callbacks is certainly a bit tedious and not necessary,
    # it can sometimes improve readability, so let's not force them to not be allowed.
    # Thus, even if you don't use `always_specify_types`, it is possible to sometimes specify
    # them on closures when it improves the readability of unfamiliar closures.
    avoid_types_on_closure_parameters: false

    # DO invoke close on instances of dart.core.Sink.
    #
    # https://dart.dev/tools/linter-rules/close_sinks.html
    #
    # Disabling it, may generate false positives. https://github.com/dart-lang/linter/issues/1381.
    close_sinks: false

    # AVOID using deprecated elements from within the package in which they are declared.
    #
    # https://dart.dev/tools/linter-rules/deprecated_member_use_from_same_package
    #
    # Elements that are annotated with @Deprecated should not be referenced from within the
    # package in which they are declared.
    deprecated_member_use_from_same_package: false

    # DO reference all public properties in debug method implementations.
    #
    # https://dart.dev/tools/linter-rules/diagnostic_describe_all_properties.html
    #
    # Consider using this lint rule if you are making a public Flutter package.
    # For private ones and private apps we recommend keeping it off as you probably
    # won't be making diagnostic properties for all your
    # classes, unless you are using a data class lib that does it for you via code generation.
    diagnostic_describe_all_properties: false

    # DO NOT use environment declared variables.
    #
    # https://dart.dev/tools/linter-rules/do_not_use_environment
    #
    # Using values derived from the environment at compile-time, creates hidden global state
    # and makes applications hard to understand and maintain.
    # DON’T use fromEnvironment or hasEnvironment factory constructors.
    do_not_use_environment: false

    # DO document lint ignores.
    #
    # https://dart.dev/tools/linter-rules/document_ignores
    #
    # Document ignore comments.
    document_ignores: false

    # DO define default behavior outside switch statements.
    #
    # https://dart.dev/tools/linter-rules/no_default_cases.html
    #
    # An experimental lint rule maturity wise. I enabled it, it seems to work well.
    # Remove the comment below if it is causing issues.
    no_default_cases: false
    omit_local_variable_types: false
    omit_obvious_local_variable_types: false
    # I like this, but it lints 'fromJson' constructors
    prefer_constructors_over_static_methods: false
    prefer_double_quotes: false
    prefer_expression_function_bodies: false
    discarded_futures: false
    # not used because of false positives in parameters
    prefer_final_parameters: false
    prefer_int_literals: false
    public_member_api_docs: false
    specify_nonobvious_local_variable_types: false
    require_trailing_commas: false
    unnecessary_final: false
    # Not used because of this issue https://github.com/dart-lang/linter/issues/3286
    use_decorated_box: false